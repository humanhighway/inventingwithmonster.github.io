{"data":{"markdownRemark":{"html":"<p>React Hooks have finally landed! So many emotions. Here‚Äôs a small selection of my own: üßê ü§Ø üòç</p>\n<p>I‚Äôve been writing a library using Hooks for about three months now, and my absolute final -never gonna bother thinking further on this- opinion on them is that they‚Äôre amazing, and can allow you to write equally amazing code.</p>\n<p>Of course, like the calorie content of Ben &#x26; Jerry‚Äôs, something so beautiful can‚Äôt exist in this universe without caveats.</p>\n<p>In the case of Hooks, those caveats come in the <a href=\"https://reactjs.org/docs/hooks-rules.html#explanation\">form of rules</a>.</p>\n<p>So today I want to talk about ‚Äúbreaking‚Äù one rule in particular. This one:</p>\n<blockquote>\n<p>Only call Hooks at the top level. Don‚Äôt call Hooks inside loops, conditions, or nested functions.</p>\n</blockquote>\n<p>The surface-level rationale behind this is that Hooks must run in the same order, every time a component is rendered.</p>\n<p>If you call a Hook within a loop, the length of the loop might change. Then, üí•.</p>\n<p>If you call a Hook conditionally, it might fire one render and not the next. Then, üí•.</p>\n<p>If you call a Hook from within a nested function, the universe will actually implode. Then, ü•¥. (No, seriously, there‚Äôs no way around this last one.)</p>\n<p>Dan Abramov goes into more specific detail about why Hooks work this way (<a href=\"https://overreacted.io/why-do-hooks-rely-on-call-order/\">https://overreacted.io/why-do-hooks-rely-on-call-order/</a>) in his blog, but the takeaway for us is:</p>\n<ol>\n<li>React knows which component is being rendered at any given time, so</li>\n<li>When a hook is called, it knows which component is calling it, so</li>\n<li>If we change the order of hooks within a component, React won‚Äôt know which is which and things break, therefore</li>\n<li>If we want to run hooks within a loop, or conditionally, we need to abstract them into a stand-alone components.</li>\n</ol>\n<p>Here‚Äôs how:</p>\n<p>Running hooks within a loop</p>\n<p>Consider the following component:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const List = ({ items }) =&gt; {\n  return items.map(item =&gt; {\n    const ref = useRef({})\n    useEffect(() =&gt; { /* Do something with ref */ })\n\n    return &lt;li ref={ref}&gt;{item.label}&lt;/li&gt;\n  })\n}</code></pre></div>\n<p>This code will actually run fine on the first render, and maybe even on subsequent renders.</p>\n<p>But consider if the length of <code class=\"language-text\">items</code> changes: A different number of hooks will be fired. Or, if they reorder, the hooks will fire in a different order.</p>\n<p>Just because this code might run correctly in some circumstances, it‚Äôs so brittle and prone to failure that we have the rule: Don‚Äôt do this!</p>\n<p>The solution</p>\n<p>As we said to start, we just need to abstract the contents of a loop so that each is a call to a separate component.</p>\n<p>Create a new component for each <code class=\"language-text\">Item</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const Item = ({ label }) =&gt; {\n  const ref = useRef({})\n  useEffect(() =&gt; { /* Do something with ref */ })\n  return &lt;li&gt;{label}&lt;/li&gt;\n}</code></pre></div>\n<p>Now we can render the Item Component from the loop:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const List = ({ items }) =&gt; {\n  return items.map(({ label }) =&gt; &lt;Item label={label} /&gt;)\n}</code></pre></div>\n<p>Now, the length and order of <code class=\"language-text\">items</code> can change without our code breaking. Whenever <code class=\"language-text\">Item</code> is rendered, React knows its rendering a different component to <code class=\"language-text\">List</code>, and that information is all it needs to correctly keep track of which Hooks are firing where.</p>\n<p>Running Hooks conditionally</p>\n<p>You might have a Hook that you only want to run conditionally, so your instinct would be to write code like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const Component = ({ enable }) =&gt; {\n  const ref = useRef()\n\n  if (enable) {\n    useComplexFunctionality(ref)\n  }\n\n  return &lt;div ref={ref} /&gt;\n}</code></pre></div>\n<p>Again, if <code class=\"language-text\">enable</code> changes, a different number of Hooks are going to be called, and React will throw an error (quite rightfully, you charlatan).</p>\n<p>The solution is the same: abstract this hook into a stand-alone component that returns <code class=\"language-text\">null</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const Functionality = forwardRef((props, ref) =&gt; {\n  useFunctionality(ref)\n  return null\n})</code></pre></div>\n<p>And render that conditionally:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const Component = ({ enable }) =&gt; {\n  const ref = useRef()\n\n  if (enable) {\n    return (\n      &lt;&gt;\n        &lt;Functionality ref={ref} /&gt;\n        &lt;div ref={ref} /&gt;\n      &lt;/&gt;\n    )\n  } else {\n    return &lt;div ref={ref} /&gt;\n  }\n}</code></pre></div>\n<p>When I first realised this, I thought it seemed a bit icky. But it‚Äôs actually totally legit.</p>\n<p>Composing functionality with components is totally React‚Äôs bag.</p>\n<p>As an added bonus, you gain lifecycle methods that are independent from the host component:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const Functionality = forwardRef((props, ref) =&gt; {\n  useFunctionality(ref)\n\n  useEffect(() =&gt; {\n    // This code will run when the functionality is first enabled,\n    // not when the host component is mounted\n\n    return () =&gt; {\n      // This code will run when the functionality is disabled,\n      // not when the host component is unmounted\n    }\n  }, [])\n\n  return null\n})</code></pre></div>\n<p>Running Hooks within a nested function</p>\n<p>No, seriously, there is no way around this. Behave.</p>","frontmatter":{"title":"How to break the rules of React Hooks","date":"07 Feb 2019"},"fields":{"slug":"/20190207-break-the-rules-of-react-hooks/","author":"mattperry","description":"We don't seen limitations, only possibilities. ~ Einstein. Or maybe Bruce Lee."}}},"pageContext":{"slug":"/20190207-break-the-rules-of-react-hooks/","author":"mattperry","description":"We don't seen limitations, only possibilities. ~ Einstein. Or maybe Bruce Lee."}}